== User guide

This is an overview of using Metadb.  We assume familiarity with databases and
the basics of SQL.

=== Getting started

Metadb extends PostgreSQL with features to support analytics such as
streaming data sources, data model transforms, and historical data. A
Metadb server behaves like a PostgreSQL database that has additional
commands (described below). Like PosgreSQL itself, it can be
interrogated using the command-line client `psql`. Various GUI tools
can also be used for querying, but it is often simpler to target those
tools at the underlying PostgreSQL database.

The data contained in the Metadb database originally come from another
place: a *data source* which could be, for example, a
transaction-processing database, a sensor network, or the database of
an ILS such as FOLIO.  Multiple sources can contribute to a single
Metadb store.  We don't presently have real-world configurations that
do this, but one situation where this would be useful might be if a
FOLIO instance has its module storage backends split across different
database instances.  Metadb updates its database continuously based on
state changes in external data sources.

=== Tables

Metadb maintains three kinds of tables based on records ingested from
sources. Most importantly, _main tables_ contain a complete history of
records that have been in the source database in all their versions;
_current tables_ contain only the current versions of records; and
_transformed tables_ (which come in both main and current flavours)
include fields extracted from JSON blobs.

The tables for a given set of records are named such that they all
begin with the same basename (and therefore sort together in a list of
tables). For example the tables containing users are `users\__` (main
table), `users` (current table), `users__t\__` (transformed main table)
and `users__t` (transformed current table).

==== Main tables

Tables generated by Metadb have at least these metadata columns, with names
that begin with two underscores:

* `__id` is a surrogate key that identifies a row in the table.

* `__start` is the date and time when the row of data was generated.

* `__end` is the date and time when the row of data became no longer
  current, or `9999-12-31 00:00:00+00` if the row is still current.

* `__current` is a Boolean value that indicates whether the row
  is current.

* `\__origin` is an optional identifier used to group related data
  from one or more data sources.  For example, Metadb can combine data
  from similar source tables into a single table in the analytic
  database, and stores an identifier in `__origin` to record where the
  data came from.

A *main table* in Metadb has two underscores at the end of its name (e.g.,
`patrongroup__`), and it contains both the current state and the history of all
previous states provided by the data source.  For instance, consider a main
table that stores categories of patrons in a library:

[source]
----
SELECT __start, __end, __current, id, groupname, description FROM library.patrongroup__;
----

[%header,cols="4m,4m,2m,>1m,2m,4m"]
|===
^|`*__start*`
^|`*__end*`
^|`*__current*`
^|`*id*`
^|`*groupname*`
^|`*description*`

|2022-04-17 21:42:25-00
|2022-04-18 19:27:18-00
|FALSE
|15
|undergrad
|Student

|2022-04-18 19:27:18-00
|9999-12-31 00:00:00+00
|TRUE
|15
|undergrad
|Undergraduate Student

|2022-04-17 21:42:25-00
|9999-12-31 00:00:00+00
|TRUE
|10
|graduate
|Graduate Student

|2022-04-17 21:52:53-00
|9999-12-31 00:00:00+00
|TRUE
|9
|faculty
|Faculty Member

|2022-04-17 21:52:53-00
|9999-12-31 00:00:00+00
|TRUE
|12
|staff
|Staff Member
|===

In this example, the "undergrad" group with `id` = 15 has two rows because it
was modified on `2022-04-18 19:27:18-00`, changing `description` from
`'Student'` to `'Undergraduate Student'`.

==== Current tables

It is often desirable to limit a query to retrieving only current records.
This can be done by filtering on `__current` = `TRUE`, for example:

[source]
----
SELECT id, groupname, description FROM library.patrongroup__ WHERE __current;
----

For convenience, since this filter is so often used, Metadb provides access to
a *current table* which contains only current records.  Every main table has a
corresponding current table, which shares the same name but without the two
underscores at the end.  For instance, the following query is equivalent to the
example above:

[source]
----
SELECT id, groupname, description FROM library.patrongroup;
----

A current table reflects the current state of each row in the data source, as
of the last time the row was updated.

.Note
****
[.text-center]
In a few database client applications, current tables do not appear by default
in the list of tables.  This is because main tables and current tables have a
parent-child relationship, and database user interfaces may show the current
table as subsumed under the main table.
****

To take another example:

[source]
----
SELECT __id, __start, __origin, id, groupname, description FROM library.patrongroup;
----

[%header,cols=">1m,4m,2m,>1m,2m,4m"]
|===
^|`*__id*`
^|`*__start*`
^|`*__origin*`
^|`*id*`
^|`*groupname*`
^|`*description*`

|8
|2022-04-18 19:27:18-00
|west
|15
|undergrad
|Undergraduate Student

|4
|2022-04-17 17:42:25-00
|east
|10
|graduate
|Graduate Student

|5
|2022-04-17 17:52:53-00
|east
|9
|faculty
|Faculty Member

|6
|2022-04-17 17:52:53-00
|east
|12
|staff
|Staff Member
|===

Current tables have all the same fields as their corresponding main
tables: even `\__current` (always `true`) `__end` (always the empty
date `00:00:00+00`).

There is a distinction between the `\__id` and `id` columns.  The `__id` column
is a key defined by Metadb to identify each row uniquely; it is present in all
tables generated by Metadb.  In contrast, the `id` column only happens to be
present in this sample table and has been provided by the data source; it may
or may not be a key, and its name, content, or significance may change if
schema changes are made in the data source.

Current table names are sometimes referred to as "base tables" because
they match the original table names in the data source.

==== Transformed tables

Metadb applies transformations to some kinds of data, which results in
additional tables being created.  One category of data that are transformed in
this way is JSON objects.  Suppose that our `patrongroup` current table
contains the `groupname` and `description` data in JSON fields, for example:

[source]
----
SELECT __id, __start, id, jsondata FROM library.patrongroup;
----

[%header,cols=">1m,4m,>1m,8m"]
|===
^|`*__id*`
^|`*__start*`
^|`*id*`
^|`*jsondata*`

|8
|2022-04-18 19:27:18-00
|15
a|
----
{
    "groupname": "undergrad",
    "description": "Undergraduate Student"
}
----

|4
|2022-04-17 17:42:25-00
|10
a|
----
{
    "groupname": "graduate",
    "description": "Graduate Student"
}
----

|5
|2022-04-17 17:52:53-00
|9
a|
----
{
    "groupname": "faculty",
    "description": "Faculty Member"
}
----

|6
|2022-04-17 17:52:53-00
|12
a|
----
{
    "groupname": "staff",
    "description": "Staff Member"
}
----
|===

The JSON fields can be selected using SQL:

[source]
----
SELECT __id,
       __start,
       id,
       jsonb_extract_path_text(jsondata, 'groupname') AS groupname,
       jsonb_extract_path_text(jsondata, 'description') AS description
    FROM library.patrongroup;
----

However, Metadb also generates a *transformed table* called `patrongroup__t`.
Transformed tables based on JSON objects contain JSON fields extracted into
columns, which allows for simpler queries.

[source]
----
SELECT __id, __start, id, groupname, description FROM library.patrongroup__t;
----

[%header,cols=">1m,4m,>1m,2m,6m"]
|===
^|`*__id*`
^|`*__start*`
^|`*id*`
^|`*groupname*`
^|`*description*`

|2
|2022-04-18 19:27:18-00
|15
|undergrad
|Undergraduate Student

|5
|2022-04-17 17:42:25-00
|10
|graduate
|Graduate Student

|4
|2022-04-17 17:52:53-00
|9
|faculty
|Faculty Member

|6
|2022-04-17 17:52:53-00
|12
|staff
|Staff Member
|===

In the current version of Metadb, only top-level, scalar JSON fields are
extracted into transformed tables. Array fields are not presently
extracted, but their values can be accessed using a lateral join as
described below.

Main tables are also transformed in the same way.  In this case the main
transformed table would be called `+patrongroup__t__+`.

Note that JSON data are treated as "schemaless," and fields are inferred from
their presence in the data rather than read from a JSON schema.  As a result, a
column is only created from a JSON field if the field is present in at least
one JSON record. More precisely, the table definition is continually created
dynamically: _each_ record added will result in the addition of a new
column if a JSON field in that record contains a field not previously
seen.

==== Comparing table types

To summarize the types of tables that we have covered:

[%header,cols="10l,13,24"]
|===
|Table name
|Table type
|Description

|patrongroup__
|Main table
|Current and historical records

|patrongroup
|Current table (base table)
|Current records only

|patrongroup__t__
|Main transformed table
|Transformed versions of the records in `patrongroup__`

|patrongroup__t
|Current transformed table
|Transformed versions of the records in `patrongroup`
|===

In addition to these table types, some partition tables have names that begin
with `zzz___`.  It is recommended that these tables not be used directly in
queries, and access to them is generally disabled.

=== User workspaces

In general, users do not have privileges to modify or create tables in the
database.  However, Metadb creates a schema for each user where the user does
have these privileges, and this serves as an individual workspace.  The schema
has the same name as the user name.  This can be useful as an area for saving
the results of queries or importing external data sets.  For example, the user
`celia` can create a table in the schema `celia`:

----
CREATE TABLE celia.westgroup AS
    SELECT * FROM library.patrongroup WHERE __origin = 'west';
----

----
SELECT * FROM celia.westgroup LIMIT 20;
----

Other users typically do not have privileges to access the table by default.

To grant the user `rosalind` read-only access to the schema and table:

----
GRANT USAGE ON SCHEMA celia TO rosalind;

GRANT SELECT ON celia.westgroup TO rosalind;
----

The user `rosalind` can then access the table.

=== Working with data types

This section offers a few brief recommendations for working with common data
types.

[discrete]
==== Text and varchar

The `text` data type is recommended for strings of characters.

The `varchar(_n_)` type with length _n_ can be used for older database clients
that require the length to be specified.

[discrete]
==== Monetary data

For monetary amounts, `numeric(19, 4)` is usually a good choice.  For exchange
rates, `numeric(19, 14)` may be used. These precisions are standard practice to avoid round-off errors in financial accounting databases.

[discrete]
==== Querying on a range of dates

There are various ways of querying within a range of dates, but the most
reliable method is to use inequalities of the form `_start_ \<= _t_ < _end_`,
for example:

----
SELECT *
    FROM folio_circulation.loan__t
    WHERE '2023-01-01' <= loan_date AND loan_date < '2024-01-01';
----

=== Creating reports

An effective way to create a report is to package it as a database function.  A
database function can define a query and associated parameters.  Users can then
call the function, specifying a value for each parameter.

For example, suppose that the following query counts the number of loans in a
library for each circulated item within a range of dates.

----
SELECT item_id,
       count(*) AS loan_count
    FROM folio_circulation.loan__t
    WHERE '2023-01-01' <= loan_date AND loan_date < '2024-01-01'
    GROUP BY item_id;
----

We can create a function to generalize this query.  Instead of including the
dates directly within the query, we will define them as parameters:
`start_date` and `end_date`.

----
CREATE FUNCTION lisa.count_loans(
    start_date date DEFAULT '2000-01-01',
    end_date date DEFAULT '2050-01-01')
RETURNS TABLE(
    item_id uuid,
    loan_count integer)
AS $$
SELECT item_id,
       count(*) AS loan_count
    FROM folio_circulation.loan__t
    WHERE start_date <= loan_date AND loan_date < end_date
    GROUP BY item_id
$$
LANGUAGE SQL
STABLE
PARALLEL SAFE;
----

Now the function can be called with different arguments to generate reports:

----
SELECT * FROM lisa.count_loans(start_date => '2022-01-01', end_date => '2023-01-01');

SELECT * FROM lisa.count_loans(start_date => '2023-01-01');
----

The user `lisa` who created this function can share it with other users in a
similar way as described in the "User workspaces" section above.

----
GRANT USAGE ON SCHEMA lisa TO celia, rosalind;

GRANT EXECUTE ON FUNCTION lisa.count_loans TO celia, rosalind;
----

Note that the `GRANT USAGE ON SCHEMA` command does not have to be run again if
it was done previously.

Defining shared functions in this way can be used together with a web-based
database tool such as CloudBeaver to make reports available to a wider group of
users.

Reports that are pushed to a GitHub repository can be run from the
FOLIO Reporting app, once that app has been configured to look in the
relevant repository for reports (Settings -> Reporting -> Report
repositories). Reports used in this way must be accompanied by a JSON
file describing the report and its parameters, so that the Reporting
app knows how to generate a form for the parameters. For more details,
see
https://github.com/folio-org/ui-ldp/blob/master/doc/reports.md[Authoring
reports for the FOLIO Reporting App] and https://github.com/folio-org/folio-analytics/wiki/Cookbook:-User-Defined-Function[Cookbook:
User Defined Function], and for examples see https://github.com/metadb-project/metadb-examples/tree/main/folio/reports.

=== Database views

Database views are not supported and should not be created in a Metadb
database.

Views can create dependencies that may block required schema changes during
data updates.  They also hide query complexity, which in analytical workloads
can be significant, behind what appears to be a simple table.  It is
recommended to use database functions instead, as described in the previous
section.

=== Querying system information

[discrete]
==== Metadb version

To show the current Metadb version:

----
SELECT mdbversion();
----

[discrete]
==== Data update times

Information about when certain tables were last updated is available
in a table called `metadb.table_update`:

----
SELECT * FROM metadb.table_update ORDER BY schema_name, table_name;
----

[discrete]
==== System log

Metadb reports errors and other information in a logging table called
`metadb.log`.  For instance to view all log messages from January, 2023:

----
SELECT *
    FROM metadb.log
    WHERE '2023-01-01' <= log_time AND log_time < '2023-02-01'
    ORDER BY log_time;
----

The `mdblog()` function is provided for convenience and returns ordered log
messages, from the past 24 hours by default (or optionally from a specified
interval):

----
SELECT * FROM mdblog();
----

[discrete]
==== Status of query process

When executing a long-running query, the `ps()` function can be used to check
on the status of the query process from another session:

----
SELECT * FROM ps();
----
