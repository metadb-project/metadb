== User guide

This is an overview of using Metadb.  We assume familiarity with databases and
the basics of SQL.

=== Getting started

Metadb extends PostgreSQL with features to support analytics such as streaming
data sources, data model transforms, and historical data.  The data contained
in the Metadb database originally come from another place: a *data source*
which could be, for example, a transaction-processing database or a sensor
network.  Metadb updates its database continuously based on state changes in
external data sources.

=== Main tables

Tables generated by Metadb have at least these metadata columns, with names
that begin with two underscores:

* `__id` is a surrogate key that identifies a row in the table.

* `__start` is the date and time when the row of data was generated.

* `__end` is the date and time when the row of data became no longer
  current, or `9999-12-31 00:00:00+00` if the row is still current.

* `__current` is a Boolean value that indicates whether the row
  is current.

* `\__origin` is an optional identifier used to group related data
  from one or more data sources.  For example, Metadb can combine data
  from similar source tables into a single table in the analytic
  database, and stores an identifier in `__origin` to record where the
  data came from.

A *main table* in Metadb has two underscores at the end of its name (e.g.,
`patrongroup__`), and it contains both the current state and the history of all
previous states provided by the data source.  For instance, consider a main
table that stores categories of patrons in a library:

[source]
----
SELECT __start, __end, __current, id, groupname, description FROM library.patrongroup__;
----

[%header,cols="4m,4m,2m,>1m,2m,4m"]
|===
^|`*__start*`
^|`*__end*`
^|`*__current*`
^|`*id*`
^|`*groupname*`
^|`*description*`

|2022-04-17 21:42:25-00
|2022-04-18 19:27:18-00
|FALSE
|15
|undergrad
|Student

|2022-04-18 19:27:18-00
|9999-12-31 00:00:00+00
|TRUE
|15
|undergrad
|Undergraduate Student

|2022-04-17 21:42:25-00
|9999-12-31 00:00:00+00
|TRUE
|10
|graduate
|Graduate Student

|2022-04-17 21:52:53-00
|9999-12-31 00:00:00+00
|TRUE
|9
|faculty
|Faculty Member

|2022-04-17 21:52:53-00
|9999-12-31 00:00:00+00
|TRUE
|12
|staff
|Staff Member
|===

In this example, the "undergrad" group with `id` = 15 has two rows because it
was modified on `2022-04-18 19:27:18-00`, changing `description` from
`'Student'` to `'Undergraduate Student'`.

=== Current tables

It is often desirable to limit a query to retrieving only current records.
This can be done by filtering on `__current` = `TRUE`, for example:

[source]
----
SELECT id, groupname, description FROM library.patrongroup__ WHERE __current;
----

For convenience, since this filter is so often used, Metadb provides access to
a *current table* which contains only current records.  Every main table has a
corresponding current table, which shares the same name but without the two
underscores at the end.  For instance, the following query is equivalent to the
example above:

[source]
----
SELECT id, groupname, description FROM library.patrongroup;
----

A current table reflects the current state of each row in the data source, as
of the last time the row was updated.

.Note
****
[.text-center]
In a few database client applications, current tables do not appear by default
in the list of tables.  This is because main tables and current tables have a
parent-child relationship, and database user interfaces may show the current
table as subsumed under the main table.
****

To take another example:

[source]
----
SELECT __id, __start, __origin, id, groupname, description FROM library.patrongroup;
----

[%header,cols=">1m,4m,2m,>1m,2m,4m"]
|===
^|`*__id*`
^|`*__start*`
^|`*__origin*`
^|`*id*`
^|`*groupname*`
^|`*description*`

|8
|2022-04-18 19:27:18-00
|west
|15
|undergrad
|Undergraduate Student

|4
|2022-04-17 17:42:25-00
|east
|10
|graduate
|Graduate Student

|5
|2022-04-17 17:52:53-00
|east
|9
|faculty
|Faculty Member

|6
|2022-04-17 17:52:53-00
|east
|12
|staff
|Staff Member
|===

There is a distinction between the `\__id` and `id` columns.  The `__id` column
is a key defined by Metadb to identify each row uniquely; it is present in all
tables generated by Metadb.  In contrast, the `id` column only happens to be
present in this sample table and has been provided by the data source; it may
or may not be a key, and its name, content, or significance may change if
schema changes are made in the data source.

=== Transformed tables

Metadb applies transformations to some kinds of data, which results in
additional tables being created.  One category of data that are transformed in
this way is JSON objects.  Suppose that our `patrongroup` current table
contains the `groupname` and `description` data in JSON fields, for example:

[source]
----
SELECT __id, __start, id, jsondata FROM library.patrongroup;
----

[%header,cols=">1m,4m,>1m,8m"]
|===
^|`*__id*`
^|`*__start*`
^|`*id*`
^|`*jsondata*`

|8
|2022-04-18 19:27:18-00
|15
a|
----
{
    "groupname": "undergrad",
    "description": "Undergraduate Student"
}
----

|4
|2022-04-17 17:42:25-00
|10
a|
----
{
    "groupname": "graduate",
    "description": "Graduate Student"
}
----

|5
|2022-04-17 17:52:53-00
|9
a|
----
{
    "groupname": "faculty",
    "description": "Faculty Member"
}
----

|6
|2022-04-17 17:52:53-00
|12
a|
----
{
    "groupname": "staff",
    "description": "Staff Member"
}
----
|===

The JSON fields can be selected using SQL:

[source]
----
SELECT __id,
       __start,
       id,
       jsondata->>'groupname' AS groupname,
       jsondata->>'description' AS description
    FROM library.patrongroup;
----

However, Metadb also generates a *transformed table* called `patrongroup__t`.
Transformed tables based on JSON objects contain JSON fields extracted into
columns, which allows for simpler queries.

[source]
----
SELECT __id, __start, id, groupname, description FROM library.patrongroup__t;
----

[%header,cols=">1m,4m,>1m,2m,6m"]
|===
^|`*__id*`
^|`*__start*`
^|`*id*`
^|`*groupname*`
^|`*description*`

|2
|2022-04-18 19:27:18-00
|15
|undergrad
|Undergraduate Student

|5
|2022-04-17 17:42:25-00
|10
|graduate
|Graduate Student

|4
|2022-04-17 17:52:53-00
|9
|faculty
|Faculty Member

|6
|2022-04-17 17:52:53-00
|12
|staff
|Staff Member
|===

In the current version of Metadb, only top-level, scalar JSON fields are
extracted into transformed tables.

Main tables are also transformed in the same way.  In this case the main
transformed table would be called `+patrongroup__t__+`.

Note that JSON data are treated as "schemaless," and fields are inferred from
their presence in the data rather than read from a JSON schema.  As a result, a
column is only created from a JSON field if the field is present in at least
one JSON record.

=== Comparing table types

To summarize the types of tables that we have covered:

[%header,cols="10l,13,24"]
|===
|Table name
|Table type
|Description

|patrongroup__
|Main table
|Current and historical records

|patrongroup
|Current table
|Current records only

|patrongroup__t__
|Main transformed table
|Transformed versions of the records in `patrongroup__`

|patrongroup__t
|Current transformed table
|Transformed versions of the records in `patrongroup`
|===

In addition to these table types, some partition tables have names that begin
with `zzz___`.  It is recommended that these tables not be used directly in
queries, and access to them is generally disabled.

=== Workspaces

In general, users do not have privileges to modify or create tables in the
database.  However, Metadb creates a schema for each user where the user does
have these privileges, and this serves as an individual workspace.  The schema
has the same name as the user name.  This can be useful as an area for saving
the results of queries or importing external data sets.  For example, the user
`celia` can create a table in the schema `celia`:

----
CREATE TABLE celia.westgroup AS
    SELECT * FROM library.patrongroup WHERE __origin = 'west';
----

----
SELECT * FROM celia.westgroup LIMIT 20;
----

Others users typically do not have privileges to access the table by default.

[.aqua-background]#Metadb v1.0.6#
To grant the user `rosalind` read-only access to the schema and table:

----
GRANT USAGE ON SCHEMA celia TO rosalind;

GRANT SELECT ON celia.westgroup TO rosalind;
----

The user `rosalind` can then access the table:

----
SELECT * FROM celia.westgroup LIMIT 20;
----

=== Creating reports

An effective way to create a report is to package it as a database function.  A
database function can define a query and associated parameters.  Users can then
call the function, specifying a value for each parameter.

For example, suppose that the following query counts the number of loans in a
library for each circulated item within a range of dates.

----
SELECT item_id,
       count(*) AS loan_count
    FROM folio_circulation.loan__t
    WHERE loan_date >= '2023-01-01' AND loan_date < '2024-01-01'
    GROUP BY item_id;
----

We can create a function to generalize this query.  Instead of including the
dates directly within the query, we will define them as parameters:
`start_date` and `end_date`.

----
CREATE FUNCTION lisa.count_loans(start_date date, end_date date)
    RETURNS TABLE(item_id uuid, loan_count integer) AS
$$
SELECT item_id,
       count(*) AS loan_count
    FROM folio_circulation.loan__t
    WHERE loan_date >= start_date AND loan_date < end_date
    GROUP BY item_id
$$
LANGUAGE SQL;
----

Now the function can be called with different arguments to generate reports:

----
SELECT * FROM lisa.count_loans('2023-01-01', '2024-01-01');

SELECT * FROM lisa.count_loans('2022-01-01', '2023-01-01');
----

[.aqua-background]#Metadb v1.0.6#
The user `lisa` who created this function can share it with other users in a
similar way as described in the "Workspaces" section above.

----
GRANT USAGE ON SCHEMA lisa TO celia, rosalind;

GRANT EXECUTE ON FUNCTION lisa.count_loans TO celia, rosalind;
----

Note that the `GRANT USAGE ON SCHEMA` command does not have to be run again if
it was done previously.

Defining shared functions in this way can be used together with a web-based
database tool such as CloudBeaver to make reports available to a wider group of
users.

=== Database views

Database views are not supported and should not be created in a Metadb
database.

Views can create dependencies that may block required schema changes during
data updates.  They also hide query complexity, which in analytical workloads
can be significant, behind what appears to be a simple table.  It is
recommended to use database functions instead, as described in the previous
section.

=== Querying system information

[discrete]
==== Metadb version

[.aqua-background]#Metadb v1.0.5#
To show the current Metadb version:

----
SELECT mdbversion();
----

[discrete]
==== Data update times

Information about when certain tables were last updated is available
in a table called `metadb.table_update`:

----
SELECT * FROM metadb.table_update ORDER BY schemaname, tablename;
----

[discrete]
==== System log

Metadb reports errors and other information in a logging table called
`metadb.log`.  For instance to view all log messages from January, 2023:

----
SELECT *
    FROM metadb.log
    WHERE log_time >= '2023-01-01' AND log_time < '2023-02-01'
    ORDER BY log_time;
----

[.aqua-background]#Metadb v1.0.5#
The `mdblog()` function is provided for convenience and returns ordered log
messages, from the past 24 hours by default (or optionally from a specified
interval):

----
SELECT * FROM mdblog();
----

[discrete]
==== Status of query process

When executing a long-running query, the `ps()` function can be used to check
on the status of the query process from another session:

----
SELECT * FROM ps();
----
